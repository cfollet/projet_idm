@uri "http://www.eclipse.org/MoDisco/Java/0.2.incubation/java"
package java;

require "kermeta"
require "http://www.eclipse.org/emf/2002/Ecore"
abstract class AbstractMethodDeclaration inherits BodyDeclaration
{
	attribute body : Block

	attribute parameters : SingleVariableDeclaration[0..*]#methodDeclaration

	attribute thrownExceptions : TypeAccess[0..*]

	attribute typeParameters : TypeParameter[0..*]

	reference usagesInDocComments : set MethodRef[0..*]#~method

	reference usages : set AbstractMethodInvocation[0..*]#~method

}
abstract class AbstractMethodInvocation inherits ASTNode
{
	reference ~method : AbstractMethodDeclaration[1..1]#usages

	attribute arguments : Expression[0..*]

	attribute typeArguments : TypeAccess[0..*]

}
abstract class AbstractTypeDeclaration inherits BodyDeclaration, Type
{
	attribute bodyDeclarations : BodyDeclaration[0..*]#abstractTypeDeclaration

	attribute commentsBeforeBody : Comment[0..*]

	attribute commentsAfterBody : Comment[0..*]

	reference ~package : Package#ownedElements

	attribute superInterfaces : TypeAccess[0..*]

}
abstract class AbstractTypeQualifiedExpression inherits Expression
{
	attribute qualifier : TypeAccess

}
abstract class AbstractVariablesContainer inherits ASTNode
{
	attribute type : TypeAccess

	attribute fragments : VariableDeclarationFragment[0..*]#variablesContainer

}
class Annotation inherits Expression
{
	attribute type : TypeAccess[1..1]

	attribute values : AnnotationMemberValuePair[0..*]

}
class Archive inherits NamedElement
{
	attribute originalFilePath : ecore::EString[1..1]

	attribute classFiles : set ClassFile[0..*]

	attribute manifest : Manifest

}
class AssertStatement inherits Statement
{
	attribute message : Expression

	attribute expression : Expression[1..1]

}
abstract class ASTNode
{
	attribute comments : Comment[0..*]

	reference originalCompilationUnit : CompilationUnit

	reference originalClassFile : ClassFile

}
class AnnotationMemberValuePair inherits NamedElement
{
	reference member : AnnotationTypeMemberDeclaration#usages

	attribute ~value : Expression[1..1]

}
class AnnotationTypeDeclaration inherits AbstractTypeDeclaration
{
}
class AnnotationTypeMemberDeclaration inherits BodyDeclaration
{
	attribute default : Expression

	attribute type : TypeAccess[1..1]

	reference usages : set AnnotationMemberValuePair[0..*]#member

}
class AnonymousClassDeclaration inherits ASTNode
{
	attribute bodyDeclarations : BodyDeclaration[0..*]#anonymousClassDeclarationOwner

	reference classInstanceCreation : ClassInstanceCreation#anonymousClassDeclaration

}
class ArrayAccess inherits Expression
{
	attribute array : Expression[1..1]

	attribute index : Expression[1..1]

}
class ArrayCreation inherits Expression
{
	attribute dimensions : Expression[0..*]

	attribute initializer : ArrayInitializer

	attribute type : TypeAccess[1..1]

}
class ArrayInitializer inherits Expression
{
	attribute expressions : Expression[0..*]

}
class ArrayLengthAccess inherits Expression
{
	attribute array : Expression[1..1]

}
class ArrayType inherits Type
{
	attribute dimensions : ecore::EInt[1..1]

	attribute elementType : TypeAccess[1..1]

}
class Assignment inherits Expression
{
	attribute leftHandSide : Expression[1..1]

	attribute operator : AssignmentKind[1..1]

	attribute rightHandSide : Expression[1..1]

}
enumeration AssignmentKind
{
	ASSIGN;
	PLUS_ASSIGN;
	MINUS_ASSIGN;
	TIMES_ASSIGN;
	DIVIDE_ASSIGN;
	BIT_AND_ASSIGN;
	BIT_OR_ASSIGN;
	BIT_XOR_ASSIGN;
	REMAINDER_ASSIGN;
	LEFT_SHIFT_ASSIGN;
	RIGHT_SHIFT_SIGNED_ASSIGN;
	RIGHT_SHIFT_UNSIGNED_ASSIGN;
}
abstract class BodyDeclaration inherits NamedElement
{
	reference abstractTypeDeclaration : AbstractTypeDeclaration#bodyDeclarations

	attribute annotations : Annotation[0..*]

	reference anonymousClassDeclarationOwner : AnonymousClassDeclaration#bodyDeclarations

	attribute modifier : Modifier#bodyDeclaration

}
class BooleanLiteral inherits Expression
{
	attribute ~value : ecore::EBoolean[1..1]

}
abstract class Expression inherits ASTNode
{
}
class BlockComment inherits Comment
{
}
abstract class Comment inherits ASTNode
{
	attribute content : ecore::EString[1..1]

	attribute enclosedByParent : ecore::EBoolean[1..1]

	attribute prefixOfParent : ecore::EBoolean[1..1]

}
class Block inherits Statement
{
	attribute statements : Statement[0..*]

}
class BreakStatement inherits Statement
{
	reference label : LabeledStatement#usagesInBreakStatements

}
class CastExpression inherits Expression
{
	attribute expression : Expression[1..1]

	attribute type : TypeAccess[1..1]

}
class CatchClause inherits Statement
{
	attribute exception : SingleVariableDeclaration[1..1]#catchClause

	attribute body : Block[1..1]

}
class CharacterLiteral inherits Expression
{
	attribute escapedValue : ecore::EString[1..1]

}
class ClassFile inherits NamedElement
{
	attribute originalFilePath : ecore::EString[1..1]

	reference type : AbstractTypeDeclaration

	reference attachedSource : CompilationUnit

	reference ~package : Package

}
class ClassInstanceCreation inherits Expression, AbstractMethodInvocation
{
	attribute anonymousClassDeclaration : AnonymousClassDeclaration#classInstanceCreation

	attribute expression : Expression

	attribute type : TypeAccess[1..1]

}
class ConstructorDeclaration inherits AbstractMethodDeclaration
{
}
class ConditionalExpression inherits Expression
{
	attribute elseExpression : Expression[1..1]

	attribute expression : Expression[1..1]

	attribute thenExpression : Expression[1..1]

}
class ConstructorInvocation inherits Statement, AbstractMethodInvocation
{
}
abstract class Statement inherits ASTNode
{
}
class ClassDeclaration inherits TypeDeclaration
{
	attribute superClass : TypeAccess

}
class CompilationUnit inherits NamedElement
{
	attribute originalFilePath : ecore::EString[1..1]

	reference commentList : Comment[0..*]

	attribute imports : ImportDeclaration[0..*]

	reference ~package : Package

	reference types : AbstractTypeDeclaration[0..*]

}
class ContinueStatement inherits Statement
{
	reference label : LabeledStatement#usagesInContinueStatements

}
class DoStatement inherits Statement
{
	attribute expression : Expression[1..1]

	attribute body : Statement[1..1]

}
class EmptyStatement inherits Statement
{
}
class EnhancedForStatement inherits Statement
{
	attribute body : Statement[1..1]

	attribute expression : Expression[1..1]

	attribute parameter : SingleVariableDeclaration[1..1]#enhancedForStatement

}
class EnumConstantDeclaration inherits BodyDeclaration, VariableDeclaration
{
	attribute anonymousClassDeclaration : AnonymousClassDeclaration

	attribute arguments : Expression[0..*]

}
class EnumDeclaration inherits AbstractTypeDeclaration
{
	attribute enumConstants : EnumConstantDeclaration[0..*]

}
class ExpressionStatement inherits Statement
{
	attribute expression : Expression[1..1]

}
class FieldAccess inherits Expression
{
	attribute field : SingleVariableAccess[1..1]

	attribute expression : Expression[1..1]

}
class FieldDeclaration inherits BodyDeclaration, AbstractVariablesContainer
{
}
class ForStatement inherits Statement
{
	attribute expression : Expression

	attribute updaters : Expression[0..*]

	attribute initializers : Expression[0..*]

	attribute body : Statement[1..1]

}
class IfStatement inherits Statement
{
	attribute expression : Expression[1..1]

	attribute thenStatement : Statement[1..1]

	attribute elseStatement : Statement

}
class ImportDeclaration inherits ASTNode
{
	attribute static : ecore::EBoolean

	reference importedElement : NamedElement[1..1]#usagesInImports

}
class InfixExpression inherits Expression
{
	attribute operator : InfixExpressionKind[1..1]

	attribute rightOperand : Expression[1..1]

	attribute leftOperand : Expression[1..1]

	attribute extendedOperands : Expression[0..*]

}
enumeration InfixExpressionKind
{
	TIMES;
	DIVIDE;
	REMAINDER;
	PLUS;
	MINUS;
	LEFT_SHIFT;
	RIGHT_SHIFT_SIGNED;
	RIGHT_SHIFT_UNSIGNED;
	LESS;
	GREATER;
	LESS_EQUALS;
	GREATER_EQUALS;
	EQUALS;
	NOT_EQUALS;
	XOR;
	AND;
	OR;
	CONDITIONAL_AND;
	CONDITIONAL_OR;
}
enumeration InheritanceKind
{
	none;
	~abstract;
	final;
}
class Initializer inherits BodyDeclaration
{
	attribute body : Block[1..1]

}
class InstanceofExpression inherits Expression
{
	attribute rightOperand : TypeAccess[1..1]

	attribute leftOperand : Expression[1..1]

}
class InterfaceDeclaration inherits TypeDeclaration
{
}
abstract class TypeDeclaration inherits AbstractTypeDeclaration
{
	attribute typeParameters : TypeParameter[0..*]

}
class Javadoc inherits Comment
{
	attribute tags : TagElement[0..*]

}
class LabeledStatement inherits NamedElement, Statement
{
	attribute body : Statement[1..1]

	reference usagesInBreakStatements : set BreakStatement[0..*]#label

	reference usagesInContinueStatements : set ContinueStatement[0..*]#label

}
class LineComment inherits Comment
{
}
class Manifest
{
	attribute mainAttributes : set ManifestAttribute[0..*]

	attribute entryAttributes : set ManifestEntry[0..*]

}
class ManifestAttribute
{
	attribute key : ecore::EString[1..1]

	attribute ~value : ecore::EString[1..1]

}
class ManifestEntry
{
	attribute name : ecore::EString

	attribute attributes : set ManifestAttribute[0..*]

}
class MemberRef inherits ASTNode
{
	reference member : NamedElement[1..1]

	attribute qualifier : TypeAccess

}
class MethodDeclaration inherits AbstractMethodDeclaration
{
	attribute extraArrayDimensions : ecore::EInt[1..1]

	attribute returnType : TypeAccess

	reference redefinedMethodDeclaration : MethodDeclaration#redefinitions

	reference redefinitions : set MethodDeclaration[0..*]#redefinedMethodDeclaration

}
class MethodInvocation inherits Expression, AbstractMethodInvocation
{
	attribute expression : Expression

}
class MethodRef inherits ASTNode
{
	reference ~method : AbstractMethodDeclaration[1..1]#usagesInDocComments

	attribute qualifier : TypeAccess

	attribute parameters : MethodRefParameter[0..*]

}
class MethodRefParameter inherits ASTNode
{
	attribute name : ecore::EString

	attribute varargs : ecore::EBoolean[1..1]

	attribute type : TypeAccess[1..1]

}
class Model
{
	attribute name : ecore::EString

	attribute ownedElements : set Package[0..*]#model

	attribute orphanTypes : set Type[0..*]

	attribute unresolvedItems : set UnresolvedItem[0..*]

	attribute compilationUnits : set CompilationUnit[0..*]

	attribute classFiles : set ClassFile[0..*]

	attribute archives : set Archive[0..*]

}
class Modifier inherits ASTNode
{
	attribute visibility : VisibilityKind[1..1]

	attribute inheritance : InheritanceKind[1..1]

	attribute static : ecore::EBoolean[1..1]

	attribute transient : ecore::EBoolean[1..1]

	attribute volatile : ecore::EBoolean[1..1]

	attribute native : ecore::EBoolean[1..1]

	attribute strictfp : ecore::EBoolean[1..1]

	attribute synchronized : ecore::EBoolean[1..1]

	reference bodyDeclaration : BodyDeclaration#modifier

	reference singleVariableDeclaration : SingleVariableDeclaration#modifier

	reference variableDeclarationStatement : VariableDeclarationStatement#modifier

	reference variableDeclarationExpression : VariableDeclarationExpression#modifier

}
enumeration VisibilityKind
{
	none;
	public;
	private;
	protected;
}
abstract class NamedElement inherits ASTNode
{
	attribute name : ecore::EString

	attribute proxy : ecore::EBoolean[1..1]

	reference usagesInImports : set ImportDeclaration[0..*]#importedElement

}
abstract class NamespaceAccess inherits ASTNode
{
}
class NumberLiteral inherits Expression
{
	attribute tokenValue : ecore::EString[1..1]

}
class NullLiteral inherits Expression
{
}
class Package inherits NamedElement
{
	attribute ownedElements : set AbstractTypeDeclaration[0..*]#~package

	reference model : Model#ownedElements

	attribute ownedPackages : set Package[0..*]#~package

	reference ~package : Package#ownedPackages

	reference usagesInPackageAccess : set PackageAccess[0..*]#~package

}
class PackageAccess inherits NamespaceAccess
{
	reference ~package : Package[1..1]#usagesInPackageAccess

	attribute qualifier : PackageAccess

}
class ParameterizedType inherits Type
{
	attribute type : TypeAccess[1..1]

	attribute typeArguments : TypeAccess[0..*]

}
class ParenthesizedExpression inherits Expression
{
	attribute expression : Expression[1..1]

}
class PostfixExpression inherits Expression
{
	attribute operator : PostfixExpressionKind[1..1]

	attribute operand : Expression[1..1]

}
enumeration PostfixExpressionKind
{
	INCREMENT;
	DECREMENT;
}
class PrefixExpression inherits Expression
{
	attribute operator : PrefixExpressionKind[1..1]

	attribute operand : Expression[1..1]

}
enumeration PrefixExpressionKind
{
	INCREMENT;
	DECREMENT;
	PLUS;
	MINUS;
	COMPLEMENT;
	NOT;
}
class PrimitiveType inherits Type
{
}
abstract class Type inherits NamedElement
{
	reference usagesInTypeAccess : set TypeAccess[0..*]#type

}
class PrimitiveTypeBoolean inherits PrimitiveType
{
}
class PrimitiveTypeByte inherits PrimitiveType
{
}
class PrimitiveTypeChar inherits PrimitiveType
{
}
class PrimitiveTypeDouble inherits PrimitiveType
{
}
class PrimitiveTypeShort inherits PrimitiveType
{
}
class PrimitiveTypeFloat inherits PrimitiveType
{
}
class PrimitiveTypeInt inherits PrimitiveType
{
}
class PrimitiveTypeLong inherits PrimitiveType
{
}
class PrimitiveTypeVoid inherits PrimitiveType
{
}
class ReturnStatement inherits Statement
{
	attribute expression : Expression

}
class SingleVariableAccess inherits Expression
{
	reference variable : VariableDeclaration[1..1]#usageInVariableAccess

	attribute qualifier : Expression

}
class SingleVariableDeclaration inherits VariableDeclaration
{
	attribute modifier : Modifier#singleVariableDeclaration

	attribute varargs : ecore::EBoolean[1..1]

	attribute type : TypeAccess[1..1]

	attribute annotations : Annotation[0..*]

	reference methodDeclaration : AbstractMethodDeclaration#parameters

	reference catchClause : CatchClause#exception

	reference enhancedForStatement : EnhancedForStatement#parameter

}
class StringLiteral inherits Expression
{
	attribute escapedValue : ecore::EString[1..1]

}
class SuperConstructorInvocation inherits Statement, AbstractMethodInvocation
{
	attribute expression : Expression

}
class SuperFieldAccess inherits AbstractTypeQualifiedExpression
{
	attribute field : SingleVariableAccess[1..1]

}
class SuperMethodInvocation inherits AbstractTypeQualifiedExpression, AbstractMethodInvocation
{
}
class SwitchCase inherits Statement
{
	attribute default : ecore::EBoolean[1..1]

	attribute expression : Expression

}
class SwitchStatement inherits Statement
{
	attribute expression : Expression[1..1]

	attribute statements : Statement[0..*]

}
class SynchronizedStatement inherits Statement
{
	attribute body : Block[1..1]

	attribute expression : Expression[1..1]

}
class TagElement inherits ASTNode
{
	attribute tagName : ecore::EString

	attribute fragments : ASTNode[0..*]

}
class TextElement inherits ASTNode
{
	attribute text : ecore::EString[1..1]

}
class ThisExpression inherits AbstractTypeQualifiedExpression
{
}
class ThrowStatement inherits Statement
{
	attribute expression : Expression[1..1]

}
class TryStatement inherits Statement
{
	attribute body : Block[1..1]

	attribute finally : Block

	attribute catchClauses : CatchClause[0..*]

}
class TypeAccess inherits Expression, NamespaceAccess
{
	reference type : Type[1..1]#usagesInTypeAccess

	attribute qualifier : NamespaceAccess

}
class TypeDeclarationStatement inherits Statement
{
	attribute declaration : AbstractTypeDeclaration[1..1]

}
class TypeLiteral inherits Expression
{
	attribute type : TypeAccess[1..1]

}
class TypeParameter inherits Type
{
	attribute bounds : TypeAccess[0..*]

}
class UnresolvedItem inherits NamedElement
{
}
class UnresolvedItemAccess inherits Expression, NamespaceAccess
{
	reference element : UnresolvedItem

	attribute qualifier : ASTNode

}
class UnresolvedAnnotationDeclaration inherits AnnotationTypeDeclaration, UnresolvedItem
{
}
class UnresolvedAnnotationTypeMemberDeclaration inherits AnnotationTypeMemberDeclaration, UnresolvedItem
{
}
class UnresolvedClassDeclaration inherits ClassDeclaration, UnresolvedItem
{
}
class UnresolvedEnumDeclaration inherits EnumDeclaration, UnresolvedItem
{
}
class UnresolvedInterfaceDeclaration inherits InterfaceDeclaration, UnresolvedItem
{
}
class UnresolvedLabeledStatement inherits LabeledStatement, UnresolvedItem
{
}
class UnresolvedMethodDeclaration inherits MethodDeclaration, UnresolvedItem
{
}
class UnresolvedSingleVariableDeclaration inherits SingleVariableDeclaration, UnresolvedItem
{
}
class UnresolvedType inherits Type, UnresolvedItem
{
}
class UnresolvedTypeDeclaration inherits AbstractTypeDeclaration, UnresolvedItem
{
}
class UnresolvedVariableDeclarationFragment inherits VariableDeclarationFragment, UnresolvedItem
{
}
class VariableDeclarationFragment inherits VariableDeclaration
{
	reference variablesContainer : AbstractVariablesContainer#fragments

}
abstract class VariableDeclaration inherits NamedElement
{
	attribute extraArrayDimensions : ecore::EInt[1..1]

	attribute initializer : Expression

	reference usageInVariableAccess : set SingleVariableAccess[0..*]#variable

}
class VariableDeclarationExpression inherits Expression, AbstractVariablesContainer
{
	attribute modifier : Modifier#variableDeclarationExpression

	attribute annotations : Annotation[0..*]

}
class VariableDeclarationStatement inherits Statement, AbstractVariablesContainer
{
	attribute extraArrayDimensions : ecore::EInt[1..1]

	attribute modifier : Modifier#variableDeclarationStatement

	attribute annotations : Annotation[0..*]

}
class WildCardType inherits Type
{
	attribute upperBound : ecore::EBoolean[1..1]

	attribute bound : TypeAccess

}
class WhileStatement inherits Statement
{
	attribute expression : Expression[1..1]

	attribute body : Statement[1..1]

}
